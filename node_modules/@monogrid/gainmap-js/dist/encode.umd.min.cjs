/**
 * @monogrid/gainmap-js v3.3.0
 * With ❤️, by MONOGRID <gainmap@monogrid.com>
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).encode={},e.three)}(this,function(e,t){"use strict";const r=async e=>{if("undefined"==typeof createImageBitmap)throw new Error("createImageBitmap() not supported.");const{source:t,mimeType:r,quality:n,flipY:a}=e;let i;if((t instanceof Uint8Array||t instanceof Uint8ClampedArray)&&"sourceMimeType"in e)i=new Blob([t],{type:e.sourceMimeType});else{if(!(t instanceof ImageData))throw new Error("Invalid source image");i=t}const o=await createImageBitmap(i),s=o.width,p=o.height;let d;"undefined"!=typeof OffscreenCanvas?d=new OffscreenCanvas(s,p):(d=document.createElement("canvas"),d.width=s,d.height=p);const h=d.getContext("2d");if(!h)throw new Error("Failed to create canvas Context");!0===a&&(h.translate(0,p),h.scale(1,-1)),h.drawImage(o,0,0,s,p);const m=await(async(e,t,r)=>{if("undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas)return e.convertToBlob({type:t,quality:r});if(e instanceof HTMLCanvasElement)return new Promise((n,a)=>{e.toBlob(e=>{e?n(e):a(new Error("Failed to convert canvas to blob"))},t,r)});throw new Error("Unsupported canvas element")})(d,r,n||.9);return{data:new Uint8Array(await m.arrayBuffer()),mimeType:r,width:s,height:p}},n=e=>{let r;if(e instanceof t.DataTexture){if(!(e.image.data instanceof Uint16Array||e.image.data instanceof Float32Array))throw new Error("Provided image is not HDR");r=e}else r=new t.DataTexture(e.data,e.width,e.height,"format"in e?e.format:t.RGBAFormat,e.type,t.UVMapping,t.RepeatWrapping,t.RepeatWrapping,t.LinearFilter,t.LinearFilter,1,"colorSpace"in e&&"srgb"===e.colorSpace?e.colorSpace:t.LinearSRGBColorSpace),"header"in e&&"gamma"in e&&(r.flipY=!0),r.needsUpdate=!0;return r},a=(e,r,n)=>{let a;switch(e){case t.UnsignedByteType:a=new Uint8ClampedArray(r*n*4);break;case t.HalfFloatType:a=new Uint16Array(r*n*4);break;case t.UnsignedIntType:a=new Uint32Array(r*n*4);break;case t.ByteType:a=new Int8Array(r*n*4);break;case t.ShortType:a=new Int16Array(r*n*4);break;case t.IntType:a=new Int32Array(r*n*4);break;case t.FloatType:a=new Float32Array(r*n*4);break;default:throw new Error("Unsupported data type")}return a};let i;class o{_renderer;_rendererIsDisposable=!1;_material;_scene;_camera;_quad;_renderTarget;_width;_height;_type;_colorSpace;_supportsReadPixels=!0;constructor(e){this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const r={format:t.RGBAFormat,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:void 0!==e.renderTargetOptions?.anisotropy?e.renderTargetOptions?.anisotropy:1,generateMipmaps:void 0!==e.renderTargetOptions?.generateMipmaps&&e.renderTargetOptions?.generateMipmaps,magFilter:void 0!==e.renderTargetOptions?.magFilter?e.renderTargetOptions?.magFilter:t.LinearFilter,minFilter:void 0!==e.renderTargetOptions?.minFilter?e.renderTargetOptions?.minFilter:t.LinearFilter,samples:void 0!==e.renderTargetOptions?.samples?e.renderTargetOptions?.samples:void 0,wrapS:void 0!==e.renderTargetOptions?.wrapS?e.renderTargetOptions?.wrapS:t.ClampToEdgeWrapping,wrapT:void 0!==e.renderTargetOptions?.wrapT?e.renderTargetOptions?.wrapT:t.ClampToEdgeWrapping};if(this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=o.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new t.Scene,this._camera=new t.OrthographicCamera,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!((e,r,n,o)=>{if(void 0!==i)return i;const s=new t.WebGLRenderTarget(1,1,o);r.setRenderTarget(s);const p=new t.Mesh(new t.PlaneGeometry,new t.MeshBasicMaterial({color:16777215}));r.render(p,n),r.setRenderTarget(null);const d=a(e,s.width,s.height);return r.readRenderTargetPixels(s,0,0,s.width,s.height,d),s.dispose(),p.geometry.dispose(),p.material.dispose(),i=0!==d[0],i})(this._type,this._renderer,this._camera,r)){let e;if(this._type===t.HalfFloatType)e=this._renderer.extensions.has("EXT_color_buffer_float")?t.FloatType:void 0;void 0!==e?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${t.FloatType}`),this._type=e):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new t.Mesh(new t.PlaneGeometry,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new t.WebGLRenderTarget(this.width,this.height,r),this._renderTarget.texture.mapping=void 0!==e.renderTargetOptions?.mapping?e.renderTargetOptions?.mapping:t.UVMapping}static instantiateRenderer(){const e=new t.WebGLRenderer;return e.setSize(128,128),e}render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(e){throw this._renderer.setRenderTarget(null),e}this._renderer.setRenderTarget(null)};toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=a(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(e){const r=new t.DataTexture(this.toArray(),this.width,this.height,t.RGBAFormat,this._type,e?.mapping||t.UVMapping,e?.wrapS||t.ClampToEdgeWrapping,e?.wrapT||t.ClampToEdgeWrapping,e?.magFilter||t.LinearFilter,e?.minFilter||t.LinearFilter,e?.anisotropy||1,t.LinearSRGBColorSpace);return r.generateMipmaps=void 0!==e?.generateMipmaps&&e?.generateMipmaps,r}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof t.ShaderMaterial&&Object.values(this.material.uniforms).forEach(e=>{e.value instanceof t.Texture&&e.value.dispose()}),Object.values(this.material).forEach(e=>{e instanceof t.Texture&&e.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}class s extends t.ShaderMaterial{_minContentBoost;_maxContentBoost;_offsetSdr;_offsetHdr;_gamma;constructor({sdr:e,hdr:r,offsetSdr:n,offsetHdr:a,maxContentBoost:i,minContentBoost:o,gamma:s}){if(!i)throw new Error("maxContentBoost is required");if(!e)throw new Error("sdr is required");if(!r)throw new Error("hdr is required");const p=s||[1,1,1],d=n||[1/64,1/64,1/64],h=a||[1/64,1/64,1/64],m=o||1,l=Math.max(i,1.0001);super({name:"GainMapEncoderMaterial",vertexShader:"\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform sampler2D sdr;\nuniform sampler2D hdr;\nuniform vec3 gamma;\nuniform vec3 offsetSdr;\nuniform vec3 offsetHdr;\nuniform float minLog2;\nuniform float maxLog2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 sdrColor = texture2D(sdr, vUv).rgb;\n  vec3 hdrColor = texture2D(hdr, vUv).rgb;\n\n  vec3 pixelGain = (hdrColor + offsetHdr) / (sdrColor + offsetSdr);\n  vec3 logRecovery = (log2(pixelGain) - minLog2) / (maxLog2 - minLog2);\n  vec3 clampedRecovery = saturate(logRecovery);\n  gl_FragColor = vec4(pow(clampedRecovery, gamma), 1.0);\n}\n",uniforms:{sdr:{value:e},hdr:{value:r},gamma:{value:(new t.Vector3).fromArray(p)},offsetSdr:{value:(new t.Vector3).fromArray(d)},offsetHdr:{value:(new t.Vector3).fromArray(h)},minLog2:{value:Math.log2(m)},maxLog2:{value:Math.log2(l)}},blending:t.NoBlending,depthTest:!1,depthWrite:!1}),this._minContentBoost=m,this._maxContentBoost=l,this._offsetSdr=d,this._offsetHdr=h,this._gamma=p,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get gamma(){return this._gamma}set gamma(e){this._gamma=e,this.uniforms.gamma.value=(new t.Vector3).fromArray(e)}get offsetHdr(){return this._offsetHdr}set offsetHdr(e){this._offsetHdr=e,this.uniforms.offsetHdr.value=(new t.Vector3).fromArray(e)}get offsetSdr(){return this._offsetSdr}set offsetSdr(e){this._offsetSdr=e,this.uniforms.offsetSdr.value=(new t.Vector3).fromArray(e)}get minContentBoost(){return this._minContentBoost}set minContentBoost(e){this._minContentBoost=e,this.uniforms.minLog2.value=Math.log2(e)}get maxContentBoost(){return this._maxContentBoost}set maxContentBoost(e){this._maxContentBoost=e,this.uniforms.maxLog2.value=Math.log2(e)}get gainMapMin(){return[Math.log2(this._minContentBoost),Math.log2(this._minContentBoost),Math.log2(this._minContentBoost)]}get gainMapMax(){return[Math.log2(this._maxContentBoost),Math.log2(this._maxContentBoost),Math.log2(this._maxContentBoost)]}get hdrCapacityMin(){return Math.min(Math.max(0,this.gainMapMin[0]),Math.max(0,this.gainMapMin[1]),Math.max(0,this.gainMapMin[2]))}get hdrCapacityMax(){return Math.max(Math.max(0,this.gainMapMax[0]),Math.max(0,this.gainMapMax[1]),Math.max(0,this.gainMapMax[2]))}}const p=e=>{const{image:r,sdr:a,renderer:i}=e,p=n(r),d=new s({...e,sdr:a.renderTarget.texture,hdr:p}),h=new o({width:p.image.width,height:p.image.height,type:t.UnsignedByteType,colorSpace:t.LinearSRGBColorSpace,material:d,renderer:i,renderTargetOptions:e.renderTargetOptions});try{h.render()}catch(e){throw h.disposeOnDemandRenderer(),e}return h};class d extends t.ShaderMaterial{_brightness=0;_contrast=1;_saturation=1;_exposure=1;_toneMapping;_map;constructor({map:e,toneMapping:r}){super({name:"SDRMaterial",vertexShader:"\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform sampler2D map;\nuniform float brightness;\nuniform float contrast;\nuniform float saturation;\nuniform float exposure;\n\nvarying vec2 vUv;\n\nmat4 brightnessMatrix( float brightness ) {\n  return mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    brightness, brightness, brightness, 1\n  );\n}\n\nmat4 contrastMatrix( float contrast ) {\n  float t = ( 1.0 - contrast ) / 2.0;\n  return mat4(\n    contrast, 0, 0, 0,\n    0, contrast, 0, 0,\n    0, 0, contrast, 0,\n    t, t, t, 1\n  );\n}\n\nmat4 saturationMatrix( float saturation ) {\n  vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n  float oneMinusSat = 1.0 - saturation;\n  vec3 red = vec3( luminance.x * oneMinusSat );\n  red+= vec3( saturation, 0, 0 );\n  vec3 green = vec3( luminance.y * oneMinusSat );\n  green += vec3( 0, saturation, 0 );\n  vec3 blue = vec3( luminance.z * oneMinusSat );\n  blue += vec3( 0, 0, saturation );\n  return mat4(\n    red,     0,\n    green,   0,\n    blue,    0,\n    0, 0, 0, 1\n  );\n}\n\nvec3 RRTAndODTFit( vec3 v ) {\n  vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n  vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n  return a / b;\n}\n\nvec3 ACESFilmicToneMapping( vec3 color ) {\n  // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n  const mat3 ACESInputMat = mat3(\n    vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n    vec3( 0.35458, 0.90834, 0.13383 ),\n    vec3( 0.04823, 0.01566, 0.83777 )\n  );\n  // ODT_SAT => XYZ => D60_2_D65 => sRGB\n  const mat3 ACESOutputMat = mat3(\n    vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n    vec3( -0.53108,  1.10813, -0.07276 ),\n    vec3( -0.07367, -0.00605,  1.07602 )\n  );\n  color = ACESInputMat * color;\n  // Apply RRT and ODT\n  color = RRTAndODTFit( color );\n  color = ACESOutputMat * color;\n  // Clamp to [0, 1]\n  return saturate( color );\n}\n\n// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf\nvec3 ReinhardToneMapping( vec3 color ) {\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 CineonToneMapping( vec3 color ) {\n  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n\n// nothing\nvec3 LinearToneMapping ( vec3 color ) {\n  return color;\n}\n\n\nvoid main() {\n  vec4 color = texture2D(map, vUv);\n\n  vec4 exposed = vec4(exposure * color.rgb, color.a);\n\n  vec4 tonemapped = vec4(TONEMAPPING_FUNCTION(exposed.rgb), color.a);\n\n  vec4 adjusted =\n    brightnessMatrix( brightness ) *\n    contrastMatrix( contrast ) *\n    saturationMatrix( saturation ) *\n    tonemapped;\n\n  gl_FragColor = adjusted;\n}\n",uniforms:{map:{value:e},brightness:{value:0},contrast:{value:1},saturation:{value:1},exposure:{value:1}},blending:t.NoBlending,depthTest:!1,depthWrite:!1}),this._map=e,this.toneMapping=this._toneMapping=r||t.ACESFilmicToneMapping,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get toneMapping(){return this._toneMapping}set toneMapping(e){let r=!1;switch(e){case t.ACESFilmicToneMapping:this.defines.TONEMAPPING_FUNCTION="ACESFilmicToneMapping",r=!0;break;case t.ReinhardToneMapping:this.defines.TONEMAPPING_FUNCTION="ReinhardToneMapping",r=!0;break;case t.CineonToneMapping:this.defines.TONEMAPPING_FUNCTION="CineonToneMapping",r=!0;break;case t.LinearToneMapping:this.defines.TONEMAPPING_FUNCTION="LinearToneMapping",r=!0;break;default:console.error(`Unsupported toneMapping: ${e}. Using LinearToneMapping.`),this.defines.TONEMAPPING_FUNCTION="LinearToneMapping",this._toneMapping=t.LinearToneMapping}r&&(this._toneMapping=e),this.needsUpdate=!0}get brightness(){return this._brightness}set brightness(e){this._brightness=e,this.uniforms.brightness.value=e}get contrast(){return this._contrast}set contrast(e){this._contrast=e,this.uniforms.contrast.value=e}get saturation(){return this._saturation}set saturation(e){this._saturation=e,this.uniforms.saturation.value=e}get exposure(){return this._exposure}set exposure(e){this._exposure=e,this.uniforms.exposure.value=e}get map(){return this._map}set map(e){this._map=e,this.uniforms.map.value=e}}const h=(e,r,n,a)=>{e.needsUpdate=!0;const i=new o({width:e.image.width,height:e.image.height,type:t.UnsignedByteType,colorSpace:t.SRGBColorSpace,material:new d({map:e,toneMapping:n}),renderer:r,renderTargetOptions:a});try{i.render()}catch(e){throw i.disposeOnDemandRenderer(),e}return i},m=e=>{const{image:t,renderer:r}=e,a=n(t),i=h(a,r,e.toneMapping,e.renderTargetOptions),o=p({...e,image:a,sdr:i,renderer:i.renderer});return{sdr:i,gainMap:o,hdr:a,getMetadata:()=>({gainMapMax:o.material.gainMapMax,gainMapMin:o.material.gainMapMin,gamma:o.material.gamma,hdrCapacityMax:o.material.hdrCapacityMax,hdrCapacityMin:o.material.hdrCapacityMin,offsetHdr:o.material.offsetHdr,offsetSdr:o.material.offsetSdr})}};e.GainMapEncoderMaterial=s,e.SDRMaterial=d,e.compress=r,e.encode=m,e.encodeAndCompress=async e=>{const t=m(e),{mimeType:n,quality:a,flipY:i,withWorker:o}=e;let s,p,d;const h=new ImageData(t.sdr.toArray(),t.sdr.width,t.sdr.height),l=new ImageData(t.gainMap.toArray(),t.gainMap.width,t.gainMap.height);if(o){const e=await Promise.all([o.compress({source:h,mimeType:n,quality:a,flipY:i}),o.compress({source:l,mimeType:n,quality:a,flipY:i})]);s=e,p=e[0].source,d=e[1].source}else s=await Promise.all([r({source:h,mimeType:n,quality:a,flipY:i}),r({source:l,mimeType:n,quality:a,flipY:i})]),p=h.data,d=l.data;return t.sdr.dispose(),t.gainMap.dispose(),{...t,...t.getMetadata(),sdr:s[0],gainMap:s[1],rawSDR:p,rawGainMap:d}},e.findTextureMinMax=(e,r="max",a)=>{const i=n(e);if(i.format!==t.AlphaFormat&&i.format!==t.RGBFormat&&i.format!==t.RGBAFormat&&i.format!==t.DepthFormat&&i.format!==t.DepthStencilFormat&&i.format!==t.RedFormat&&i.format!==t.RedIntegerFormat&&i.format!==t.RGFormat&&i.format!==t.RGIntegerFormat&&i.format!==t.RGBIntegerFormat&&i.format!==t.RGBAIntegerFormat)throw new Error("Unsupported texture format");const s=new t.ShaderMaterial({vertexShader:"\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\nprecision mediump float;\n\n#ifndef CELL_SIZE\n  #define CELL_SIZE 2\n#endif\n\n#ifndef COMPARE_FUNCTION\n  #define COMPARE_FUNCTION max\n#endif\n\n#ifndef INITIAL_VALUE\n  #define INITIAL_VALUE 0\n#endif\n\nuniform sampler2D map;\nuniform vec2 u_srcResolution;\n\nvarying vec2 vUv;\n\nvoid main() {\n  // compute the first pixel the source cell\n  vec2 srcPixel = floor(gl_FragCoord.xy) * float(CELL_SIZE);\n\n  // one pixel in source\n  vec2 onePixel = vec2(1) / u_srcResolution;\n\n  // uv for first pixel in cell. +0.5 for center of pixel\n  vec2 uv = (srcPixel + 0.5) * onePixel;\n\n  vec4 resultColor = vec4(INITIAL_VALUE);\n\n  for (int y = 0; y < CELL_SIZE; ++y) {\n    for (int x = 0; x < CELL_SIZE; ++x) {\n      resultColor = COMPARE_FUNCTION(resultColor, texture2D(map, uv + vec2(x, y) * onePixel));\n    }\n  }\n\n  gl_FragColor = resultColor;\n}\n",uniforms:{u_srcResolution:{value:new t.Vector2(i.image.width,i.image.height)},map:{value:i}},defines:{CELL_SIZE:2,COMPARE_FUNCTION:r,INITIAL_VALUE:"max"===r?0:65504}});i.needsUpdate=!0,s.needsUpdate=!0;let p=i.image.width,d=i.image.height;const h=new o({width:p,height:d,type:i.type,colorSpace:i.colorSpace,material:s,renderer:a}),m=[];for(;p>1||d>1;){p=Math.max(1,(p+2-1)/2|0),d=Math.max(1,(d+2-1)/2|0);const e=new t.WebGLRenderTarget(p,d,{type:h.type,format:i.format,colorSpace:h.colorSpace,minFilter:t.NearestFilter,magFilter:t.NearestFilter,wrapS:t.ClampToEdgeWrapping,wrapT:t.ClampToEdgeWrapping,generateMipmaps:!1,depthBuffer:!1,stencilBuffer:!1});m.push(e)}p=i.image.width,d=i.image.height,m.forEach(e=>{p=Math.max(1,(p+2-1)/2|0),d=Math.max(1,(d+2-1)/2|0),h.renderTarget=e,h.render(),s.uniforms.map.value=e.texture,s.uniforms.u_srcResolution.value.x=p,s.uniforms.u_srcResolution.value.y=d});const l=h.toArray();return h.dispose(),m.forEach(e=>e.dispose()),[h.type===t.FloatType?l[0]:t.DataUtils.fromHalfFloat(l[0]),h.type===t.FloatType?l[1]:t.DataUtils.fromHalfFloat(l[1]),h.type===t.FloatType?l[2]:t.DataUtils.fromHalfFloat(l[2])]},e.getGainMap=p,e.getSDRRendition=h});
